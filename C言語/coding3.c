/*
配列とポインタ

int *p = &(ary[0]);
↓
int* p = ary ;

ary[1]のデータをポインタで参照したいとき、
*(p + 1)で可能。

構造体は、さまざまな型が集まってできています。
int型のメンバー width とdouble型のメンバー height を
メンバーにもつ構造体 struct size は、次のように宣言します。

struct size {
  int width;  // 幅
  int height; // 高さ
};
構造体 struct size へのポインターの型は struct size * です。

struct size s = { 2, 3 };
struct size* ps = &s1;


psのように、構造体へのポインターの型である変数を使っているときは、
構造体のメンバーを参照するのに -> 演算子を使います。

// . 演算子を使った参照
print("%d, %d\n", s.width, s.height); // 2, 3
// -> 演算子を使った参照
print("%d, %d\n", ps->width, ps->height); // 2, 3

構造体のメンバーへのポインターとなる変数を用意したいときは、
次のようにして構造体のメンバーを参照するための値（アドレス）を取得します。

int *pw = &s.width;

----------------------------------------------------------------------

配列は、代入演算子による代入はできません。

int a[] = { 1, 2, 3 };
int b[3];
b = a; // エラー

この場合、aはポインター生成により int * へと変換されますので、
左辺の型 int [3] とは一致しなくなります。
配列aを配列bにコピーするためには、要素を一つずつ代入します。


一般的に、作ろうとしている関数が次のような場合に、
ポインターを使い、参照渡しを行う。

・配列を受け取るとき
・渡されるオブジェクトのサイズが大きい、あるいはサイズが不明で、
コピーするのに無視できないコストがかかる可能性があるとき
・渡されたオブジェクトをそのものを変更するとき
・戻り値以外に値を返したいとき


配列を受け取るには、ポインターを使って次のように書きます。

// 配列を受け取る関数
void func(int *ary) {
  for (int i = 0; i < 2; i++) {
    printf("ary[%d]=%d\n", i, ary[i]);
  }
}

int main(void) {
  int ary[] = { 1, 2, 3 };
  func(ary);
  return EXIT_SUCCESS;
}

// 次の3つはすべて同じ意味
void func(int *ary);
void func(int ary[]);
void func(int ary[3]);



関数で配列の配列（2次元配列）を受け取るときは次のようにします。

// 配列の配列を受け取る関数
void func(int (*ary)[3]) {
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      printf("ary[%d][%d]=%d\n", i, j, ary[i][j]);
    }
  }
}


int main(void) {
  int ary2[][3] = { { 1, 2, 3 },
                    { 4, 5, 6 } };
  func(ary2);
  return EXIT_SUCCESS;
}

関数funcに渡しているオブジェクトary2の型はint型の要素を持つ配列の配列ですが、
ポインター生成により int (*)[3]、つまり「int型の要素を3つ持つ配列へのポインター」となります。
この丸カッコ()は必須です。これがないとaryの前にある*よりも先に[]が解釈されてしまい、
「intへのポインター型の要素を3つ持つ配列」になってしまいます。
また、int (*ary)[3] は int ary[][3] と書いてもまったく同じです。

　ただしいずれの場合でも、int (*ary)[3] の3は省略できません。
配列aryの要素を参照するには ary[n][m]（nとmは整数型）のようにします。
このとき、型の大きさが明確でないと参照先の位置を特定することができないため、
コンパイルするときにエラーになってしまいます。
つまり、ary[n] の大きさをコンパイラに伝える必要があるということです。


*/
