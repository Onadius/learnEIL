//文字列処理
/*
#include <string.h> 宣言の必要あり

strcpy( , )
strlen() : 文字列の長さを返す

などの関数。。。
*/


//メモリ管理
/*
#include <stdlib.h> 宣言の必要あり

malloc メモリブロック確保
free メモリブロック解放

ex.

char *p ;
p = (char *)malloc(1000) ;
if(p == NULL) {
  printf("メモリ確保不可能") ;
  exit(1) ; //処理を打ち切る
}

(仕事)

free(p) ;


sizeof(型);
とやればそのデータ型のバイトサイズを計算してくれます

(1)確保・開放を１つのペアとして考える

まずは、基本中の基本ですが、malloc()で確保したメモリは、必ずfree()で開放します。
この２つの関数は、２つで１つだと思ってください。malloc()を書いたら、
必ず対応するfree()を記述します。malloc()だけ書いてfree()を書かないなんてことは、
どんな場合でもありえません。

malloc戻り値は確保したメモリのポインタがvoid型で返ってきます。
失敗した場合はNULLが返ります。

「プログラムが終了したら自動的に開放されるから、開放しなくてもいいや」
なんて考えてはいけません。自動的に開放されるかされないかに関わらず、
「自分で確保したものは、必ず自分で開放する」という考えを持つことが大切です。
自分のプログラム内で完結するように作れば、少なくとも自分の責任でメモリリークが
おきることがないことが保証できるからです。

(2)原則として、関数内で確保・開放を完結させる
動的なメモリを確保する場合、大きく分けると、プログラム全体で使うような
グローバルなデータで、サイズの大きいものを作る場合と、
関数内で一時的に大きなサイズのデータを使いたい場合の２通りがあります。

関数内で確保・開放する場合は、関数の先頭で確保し、関数の最後で開放します。
そして、関数からのreturnは関数の最後だけに書きます。
*/





























/**/
